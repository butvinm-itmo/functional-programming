В качестве языка программирования на курс ФП я хотел бы выбрать Рефал.


## Почему Рефал

Со многими концепциями ФП я уже познакомился, пробовал разные ФЯ, читал про лямбда-счисления, теорию типов, теорию категорий.
В ходе курса я смогу изучить их подробнее и попробовать разные "мейнстримные" языки.

Рефал же стоит особняком среди других функциональных языков.
Он строится на другой математической модели и этот новый способ мыслить и смотреть на программы я бы и хотел освоить.

К тому же, Рефал и его комьюнити тесно связаны с областью Суперкомпиляции, в которую я тоже хотел бы погрузиться.
Компилятор Рефала-5λ, который я собираюсь использовать, является "детской площадкой" для PHD, где они защищают свои кандидатские работы по суперкомпиляции,
и прямо в репозитории можно найти много интересных статей, а в issue проследить за обсуждением идей.

Рефал обладает большим количеством интересных особенностей, которые отличают его от других функциональных языков.

В отличие от языков строящихся на S-выражениях, Рефал строится на R-выражениях, который позволяют разбивать выражения на произвольное количество частей, а не только на голову-хвост, что делает его синтаксис в разы выразительнее.
Если вы не писали на Рефал, вы не знаете, что такое по-настоящему *декларативное* программирование.
Если честно, после Рефала мне физически больно пользоваться петтерн-матчингом в других языках.

Просто посмотрите на этот код для парсинга упрощенного XML. Он выглядит как буквальное описание синтаксиса XML, нет никакой программатики и прочих странностей языка, вынесенных на уровень семантики.

```refal
ParseElem {
  e.Root = <Trim e.Root> : {
    '<' e.Tag '>' e.Content '</' e.Tag '>' e.Rest
      = (Element (e.Tag) <ParseElem e.Content>) <ParseElem e.Rest>;

    '<' e.Tag '>' e.Content '</' e.Tag '>'
      = (Element (e.Tag) <ParseElem e.Content>);

    e.Text
      = (Text e.Text);
  }
}
```

Благодаря особенности работы Рефал-машины, Рефал освобождает программиста от еще одной проблемы, портящей интуитивность кода - необходимость применения хвостовой рекурсии.
Так как активное выражение после сопоставления заменяется "на месте", код, приведенный ниже, не будет накапливать результаты рекурсивных вызовов на стеке.

```refal
ReplaceAWithB {
  'a' e.Rest = 'b' <Fab e.Rest>;
  s.Other e.Rest = s.Other <Fab e.Rest>;
  /* empty */ = /* empty */;
}
```

В языке небольшая встроенная библиотека, но есть возможность биндинга и нативных вставок на C++.

## Актуальность для курса

Несмотря на то, что Рефал сильно отличается от других функциональных языков, он все еще позволяет освоить основные концепции ФП.

В языке присутствует сопоставление образцов (паттерн-матчинг), рекурсия, неизменяемость данных (но полностью чистым язык не является).
Благодаря расширению Рефал-5λ, в нем появляются функции высшего порядка и безымянные функции, что позволяет реализовывать многие паттерны ФП,
такие как функции высшего порядка, замыкания, каррирование и т.д.

Минусом для курса является нетипизированность Рефала (и алгорифмов Маркова в целом).
Поэтому концепции теории типов я планирую освоить, читая параллельно с прохождением курса ["Category Theory For Programmers"](https://github.com/hmemcpy/milewski-ctfp-pdf) Bartosz Milewski.


## Skill issue or turing tarpit?

Чтобы позже не столкнуться с тем, что язык (или я) не пригоден для программирования, перед выбором я попробовал написать несколько программ на Рефал.

Я решил пару задачек с [Project Euler](https://github.com/butvinm/refal-euler), [библиотеку для использования концепции генераторов](https://github.com/butvinm/refal-generators) и [интерпретатор языка описания Тьюринг-машин](https://github.com/butvinm/retula)

Выводы: на Рефал можно писать, пишется легко, отладка трудностей не доставляет (хотя формат трассировки очень специфичный, нужно привыкать).

## Инструменты

### Компилятор

Как я уже сказал, я собираюсь использовать диалект [Рефал-5λ](https://github.com/bmstu-iu9/refal-5-lambda).
До 2018 проект поддерживался довольно активно, большая часть работ шла по улучшению суперкомпиляции, багов не так много.
По опыту использования, проблем особо не возникло. Компилятор не самый дружелюбный, но рабочий.

### Линтеры, форматеры

Здесь грустно - их нет. Но есть [style guide](https://github.com/bmstu-iu9/refal-5-lambda/blob/master/doc/style-guide.md) в репозитории компилятора. Его, с небольшими корректировками, я и буду использовать.
В целом, у языка простой синтаксис и придерживаться стиля самостоятельно не составляет труда.

Никто не хочет написать линтер на Рефале в качестве 4 лабы? :3

### Тесты

В рамках библиотеки для генераторов я также выработал подход к тестированию, можно посмотреть [здесь](https://github.com/butvinm/refal-generators/blob/master/tests/Test.ref).

Для 4 лабы хорошо подойдет Snapshot testing (golden tests, behavior tests). Подойдет [rere.py](https://github.com/tsoding/rere.py).

## Что прочитал при подготовке

- Начал читать ["Лекции по языку программирования Рефал"](http://refal.botik.ru/library/refal2014_main_refal-2006.pdf) А. П. Немытых. Их и планирую защищать на зачете
- Компьютерра "Рефал как язык для обработки xml-документов"
- Документацию по языку в репозитории компилятора

Основным источником информации по Рефал является документация и исходные коды компилятора Рефал-5λ. В них можно найти подробное описание как базисного Рефала, так и Рефал-5λ и много информации о работе Рефал-машины.
В коде компилятора можно так же подсматривать архитектурные и стилевые идеи.


## Идеи на 4 лабораторную

Рефал задумывался как метаязык для описания и преобразования других языков. Его синтаксис и семантика позволяют очень легко писать парсеры и делать текстовый преобразования.

Поэтому для 4 лабораторной я решил выбрать проект, максимально раскрывающий особенности языка - интерпретатор/компилятор языка подобного [tula](https://github.com/tsoding/tula?tab=readme-ov-file).

tula - язык для описания Тьюринг-машины. Пример программ:

```tula
case Inc 0 1 -> Halt
case Inc 1 0 -> Inc

trace Inc { 1 1 0 1 }
```

```tula
for a b in Numbers
  case Swap (a b) (b a) -> Swap

case Swap & & -> Halt

trace Swap { (1 2) (2 3) (3 4) & }
```

Конечно, написание интерпретатора/компилятора довольно комплексная задача, но чтобы не застрять и не провалить сроки, фичи в язык можно добавлять постепенно.

Простейшую реализацию ~~можно буквально за пару часов написать~~ я написал за несколько часов.

К тому же, есть исходные коды и стримы по созданию интерпретатора tula, которые можно использовать в качестве референса.

![](./xkcd.jpg)
